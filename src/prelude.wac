import fn "lang" "hello" __hello()
import fn "lang" "print_i32" __print_i32(i32)
import fn "lang" "print_f32" __print_f32(f32)
import fn "lang" "print_cstr" __print_cstr(i32)
import fn "lang" "cstrlen" __cstrlen(i32) i32

# We define the entrypoint to be __start so that main can be private
fn[pub] __start() i32 {
    Main()
    0
}

var __WAC_heap_start = $asm([], i32, "global.get $rt_heap_start")
var __WAC_heap_end = __WAC_heap_start

var __WAC_freelist_16 = 0
var __WAC_freelist_64 = 0
var __WAC_freelist_256 = 0
var __WAC_freelist_1024 = 0

# Number of bytes in a page
var __WAC_PAGE_SIZE = 65536

fn __malloc(len i32) i32 {
    if len <= 16 {
        if __WAC_freelist_16 is 0 {
        }
    }
    0
}

fn __free(len i32, ptr i32) {
}

fn __WAC_alloc(len i32) i32 {
    # align to 16-bytes
    len = (len + (16 - 1)) // 16

    var ptr = __WAC_heap_end

    var required_page_count = (ptr + __WAC_PAGE_SIZE - 1) // __WAC_PAGE_SIZE
    var current_page_count = $asm([], i32, "memory.size")

    if current_page_count < required_page_count {
        if $asm([required_page_count - current_page_count], i32, "memory.grow") is -1 {
            # TODO: out of memory, alert in some way
        }
    }

    __WAC_heap_end = __WAC_heap_end + len
    ptr
}

fn __WAC_page_count() i32 {
    $asm([], i32, "memory.size")
}
