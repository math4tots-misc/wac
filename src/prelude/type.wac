fn type[notrace](x id) type {
    $asm([], type, r#"
        local.get $l_0_x
        i64.const 32
        i64.shr_u
        i32.wrap_i64
    "#)
}

fn __WAC_typeof_raw[notrace](x i64) type {
    $asm([], type, r#"
        local.get $l_0_x
        i64.const 32
        i64.shr_u
        i32.wrap_i64
    "#)
}

fn __type_str[notrace](t type) str {
    var raw_type = $asm([t], i32, "")

    # ptr to the str value
    var ptr = __read(
        $asm([], i32, "global.get $rt_typestr_table_start") +
        raw_type * 4
    )

    # manually retain the value, so that we can asm cast it
    # into str
    __WAC_ptr_retain(ptr)

    $asm([ptr], str, "")
}

fn __type_is_enum[notrace](type type) bool {
    var i = $asm([type], i32, "")
    i > $asm([id], i32, "") and i % 2 is 1
}

fn __type_is_record[notrace](type type) bool {
    var i = $asm([type], i32, "")
    i > $asm([id], i32, "") and i % 2 is 0
}

fn __type_enum_value_name[notrace](value id) str {
    var value_type = type(value)
    if !__type_is_enum(value_type) {
        NoTracePanic("__type_enum_value_name: not an enum")
    }
    var enum_type_offset = (
        ($asm([value_type], i32, "") - $asm([id], i32, "")) // 2
    )
    var info_ptr = __read(
        $asm([], i32, "global.get $rt_enum_meta_buffer_start") +
        enum_type_offset * 4,
    )
    var raw_value = $asm([], i32, r#"
        local.get $l_0_value
        i32.wrap_i64
    "#)
    var str_ptr = __read(info_ptr + 4 + raw_value * 4)
    __WAC_ptr_retain(str_ptr)
    $asm([str_ptr], str, "")
}
