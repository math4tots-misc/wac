
fn str(x id) str {
    # TODO: once traits are implemented, make this a trait fn
    if type(x) is str {
        x
    } else {
        NoTracePanic("TODO str")
    }
}

fn Print(x id) {
    __print_str(str(x))
}

fn PrintErr(x id) {
    __eprint_str(str(x))
}

# str layout:
#   [refcnt i32][len(bytes) i32][utf8...]
#
fn __WAC_str_release[notrace](ptr i32) {
    var refcnt = __read(ptr) - 1
    if refcnt > 0 {
        # __hello($cstr("STRING (RELEASE)"), refcnt)
        __write(ptr, refcnt)
    } else {
        # __hello($cstr("STRING IS BEING FREED!!"), ptr)
        __free(__read(ptr + 4) + 8, ptr)
    }
}

fn __WAC_str_retain[notrace](ptr i32) {
    __write(ptr, __read(ptr) + 1)
    # __hello($cstr("STRING (RETAIN)"), __read(ptr))
}

fn __WAC_str_alloc(strlen i32) str {
    # Allocates space for string of a given length
    var ptr = __malloc(8 + strlen)
    __write(ptr, 1)           # refcnt
    __write(ptr + 4, strlen)  # strlen in bytes
    $asm([ptr], str, "")
}

fn __WAC_str_buffer[notrace](s str) i32 {
    # Returns the pointer to the string's buffer
    $asm([], i32, r###"
        local.get $l_0_s
        i32.const 8
        i32.add
    "###)
}

# concatenates two strings
fn __str_cat(a str, b str) str {
    var alen = __strlen(a)
    var blen = __strlen(b)
    var strlen = alen + blen
    var ret = __WAC_str_alloc(strlen)

    var abuf = __WAC_str_buffer(a)
    var bbuf = __WAC_str_buffer(b)
    var rbuf = __WAC_str_buffer(ret)

    __WAC_memcpy(rbuf,        abuf, alen)
    __WAC_memcpy(rbuf + alen, bbuf, blen)

    ret
}

fn __print_str[notrace](s str) {
    var ptr = __WAC_UNSAFE_strptr(s)
    __print_str_raw(__read(ptr + 4), ptr + 8)
}

fn __eprint_str[notrace](s str) {
    var ptr = __WAC_UNSAFE_strptr(s)
    __eprint_str_raw(__read(ptr + 4), ptr + 8)
}

fn __eprint0_str[notrace](s str) {
    var ptr = __WAC_UNSAFE_strptr(s)
    __eprint0_str_raw(__read(ptr + 4), ptr + 8)
}

fn __strlen[notrace](s str) i32 {
    # Gets the length of the given string
    # (i.e. number of bytes in its utf8 representation)
    var ptr = $asm([], i32, "local.get $l_0_s")
    __read(ptr + 4)
}

impl str SizeOf(self) i32 {
    __strlen(self)
}

fn __WAC_UNSAFE_strptr[notrace](s str) i32 {
    # Returns the given str as an i32
    # This is unsafe since if the last reference was given,
    # the returned pointer would point to freed data
    $asm([], i32, "local.get $l_0_s")
}
