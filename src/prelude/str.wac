
# str layout:
#   [refcnt i32][len(bytes) i32][utf8...]
#
fn __WAC_str_release[notrace](ptr i32) {
    var refcnt = __read(ptr) - 1
    if refcnt > 0 {
        __write(ptr, refcnt)
    } else {
        __free(__read(ptr + 4) + 8, ptr)
    }
}

fn __WAC_str_alloc[notrace](strlen i32) str {
    # Allocates space for string of a given length
    var ptr = __malloc(8 + strlen)
    __write(ptr, 1)           # refcnt
    __write(ptr + 4, strlen)  # strlen in bytes
    $asm([ptr], str, "")
}

fn __WAC_str_buffer[notrace](s str) i32 {
    # Returns the pointer to the string's buffer
    $asm([], i32, r###"
        local.get $l_0_s
        i32.const 8
        i32.add
    "###)
}

# Joins a list of strings with the given separator
fn __str_join[notrace](separator str, items list) str {
    var separator_len = __strlen(separator)
    var separator_buffer = __WAC_str_buffer(separator)
    var items_len = __listlen(items)

    var final_len = 0
    var i = 0
    while i < items_len {
        if i > 0 {
            final_len = final_len + separator_len
        }
        final_len = final_len + __strlen(__list_getitem(items, i))
        i = i + 1
    }

    var ret = __WAC_str_alloc(final_len)
    var buffer = __WAC_str_buffer(ret)

    i = 0
    while i < items_len {
        if i > 0 {
            __WAC_memcpy(buffer, separator_buffer, separator_len)
            buffer = buffer + separator_len
        }
        var item str = __list_getitem(items, i)
        var item_len = __strlen(item)
        var item_buffer = __WAC_str_buffer(item)
        __WAC_memcpy(buffer, item_buffer, item_len)
        buffer = buffer + item_len
        i = i + 1
    }

    ret
}

# concatenates two strings
fn __str_cat(a str, b str) str {
    var alen = __strlen(a)
    var blen = __strlen(b)
    var strlen = alen + blen
    var ret = __WAC_str_alloc(strlen)

    var abuf = __WAC_str_buffer(a)
    var bbuf = __WAC_str_buffer(b)
    var rbuf = __WAC_str_buffer(ret)

    __WAC_memcpy(rbuf,        abuf, alen)
    __WAC_memcpy(rbuf + alen, bbuf, blen)

    ret
}

fn __str_eq(a str, b str) bool {
    var alen = __strlen(a)
    var blen = __strlen(b)
    var abuf = __WAC_str_buffer(a)
    var bbuf = __WAC_str_buffer(b)

    if alen is blen {
        var eq_so_far = true
        var i = 0
        while eq_so_far and i + 4 < alen {
            eq_so_far = __read(abuf + i) is __read(bbuf + i)
            i = i + 4
        }
        while eq_so_far and i < alen {
            eq_so_far = __read_u8(abuf + i) is __read_u8(bbuf + i)
            i = i + 1
        }
        eq_so_far
    } else {
        false
    }
}

fn __print_str[notrace](s str) {
    var ptr = __WAC_UNSAFE_strptr(s)
    __print_str_raw(__read(ptr + 4), ptr + 8)
}

fn __eprint_str[notrace](s str) {
    var ptr = __WAC_UNSAFE_strptr(s)
    __eprint_str_raw(__read(ptr + 4), ptr + 8)
}

fn __eprint0_str[notrace](s str) {
    var ptr = __WAC_UNSAFE_strptr(s)
    __eprint0_str_raw(__read(ptr + 4), ptr + 8)
}

fn __strlen[notrace](s str) i32 {
    # Gets the length of the given string
    # (i.e. number of bytes in its utf8 representation)
    var ptr = $asm([], i32, "local.get $l_0_s")
    __read(ptr + 4)
}

fn __WAC_UNSAFE_strptr[notrace](s str) i32 {
    # Returns the given str as an i32
    # This is unsafe since if the last reference was given,
    # the returned pointer would point to freed data
    $asm([], i32, "local.get $l_0_s")
}
