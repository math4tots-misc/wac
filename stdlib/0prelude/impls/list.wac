
# list layout:
#   [refcnt i32][len(count) i32][capacity(count) i32][ptr to buffer i32]
#
# The actual buffer is an array of i64 'id' objects
#
fn __WAC_list_release[notrace](ptr i32) {
    var refcnt = __read(ptr) - 1
    if refcnt > 0 {
        __write(ptr, refcnt)
    } else {

        var len = __read(ptr + 4)
        var buf = __read(ptr + 12)

        # release each of the entries in this list
        var i = 0
        while i < len {
            __WAC_id_release(__read_i64(buf + 8 * i))
            i = i + 1
        }

        # free the buffer
        __free(__read(ptr + 8) * 8, buf)

        # free the info
        __free(16, ptr)
    }
}

fn __listlen[notrace](s list) i32 {
    # Gets the length of the given list
    var ptr = $asm([], i32, "local.get $l_0_s")
    __read(ptr + 4)
}

fn __WAC_UNSAFE_listptr[notrace](s list) i32 {
    # Returns the given list as an i32
    # This is unsafe since if the last reference was given,
    # the returned pointer would point to freed data
    $asm([], i32, "local.get $l_0_s")
}

fn __new_list[notrace]() list {
    var ptr = __malloc(16)

    # refcnt
    __write(ptr, 1)

    # len (starts empty)
    __write(ptr + 4, 0)

    # capacity (starts with no allocation)
    __write(ptr + 8, 0)

    # ptr to buffer (starts as null)
    __write(ptr + 12, 0)

    $asm([], list, "local.get $l_0_ptr")
}

fn __list_push[notrace](list list, item id) {
    var raw_list = $asm([], i32, "local.get $l_0_list")
    var raw_item = $asm([], i64, "local.get $l_1_item")
    __WAC_id_retain(raw_item)
    __WAC_list_push_raw_no_retain(raw_list, raw_item)
}

fn __WAC_list_push_raw_no_retain[notrace](list i32, item i64) {

    var len = __read(list + 4)
    var capacity = __read(list + 8)

    if capacity < len + 1 {
        var new_capacity = if capacity is 0 {
            2
        } else {
            capacity * 4
        }

        # Update the 'capacity' field
        __write(list + 8, new_capacity)

        # Update with larger buffer
        __write(
            list + 12,
            __realloc(8 * capacity, 8 * new_capacity, __read(list + 12)),
        )
    }

    # update the 'len' field
    __write(list + 4, len + 1)

    var buffer = __read(list + 12)

    __write_i64(buffer + 8 * len, item)
}

fn __list_pop[notrace](list list) id {
    # There's no need to release manually,
    # we're just transferring the retain that this list had to the
    # reference to the retain we would've needed to do for a
    # return value
    $asm([__WAC_list_pop_raw_no_release(
        $asm([], i32, "local.get $l_0_list"),
    )], id, "")
}

fn __WAC_list_pop_raw_no_release[notrace](list i32) i64 {
    var new_len = __read(list + 4) - 1
    if new_len < 0 {
        NoTracePanic("Pop from empty list")
    }
    __write(list + 4, new_len)

    # buffer[new_len]
    __read_i64(__read(list + 12) + 8 * new_len)
}

fn __list_getitem[notrace](list list, index i32) id {
    var len = __listlen(list)
    var index = __index(index, len)

    var buffer = __list_buffer(list)
    var raw_item = __read_i64(buffer + index * 8)

    # We have to retain for the return
    __WAC_id_retain(raw_item)

    $asm([raw_item], id, "")
}

fn __list_setitem[notrace](list list, index i32, value id) {
    var len = __listlen(list)
    var index = __index(index, len)

    var buffer = __list_buffer(list)
    var item_ptr = buffer + index * 8

    # Retain the new item (for ownership in list)
    __WAC_id_retain($asm([], i64, "local.get $l_2_value"))

    # Release the old item
    __WAC_id_release(__read_i64(item_ptr))

    # Actually replace the value
    __write_i64(item_ptr, $asm([], i64, "local.get $l_2_value"))
}

# Get a pointer to the list's buffer
fn __list_buffer[notrace](list list) i32 {
    __read($asm([], i32, "local.get $l_0_list") + 12)
}

fn __list_reverse[notrace](items list) {
    var len = __listlen(items)
    var buffer = __list_buffer(items)

    var i = 0
    while i + i < len {
        var ptr1 = buffer + 8 * i
        var ptr2 = buffer + 8 * (len - 1 - i)
        var tmp = __read_i64(ptr1)
        __write_i64(ptr1, __read_i64(ptr2))
        __write_i64(ptr2, tmp)
        i = i + 1
    }
}

fn __list_swap[notrace](items list, i i32, j i32) {
    var tmp = __list_getitem(items, i)
    __list_setitem(items, i, __list_getitem(items, j))
    __list_setitem(items, j, tmp)
}

fn __list_clone[notrace](items list) list {
    var len = __listlen(items)
    var ret = __new_list()
    var i = 0
    while i < len {
        __list_push(ret, __list_getitem(items, i))
        i = i + 1
    }
    ret
}

fn __list_eq(a list, b list) bool {
    var len = __listlen(a)
    len is __listlen(b) and {
        var i = 0
        var maybe_eq = true
        while maybe_eq and i < len {
            maybe_eq = a[i] == b[i]
            i = i + 1
        }
        maybe_eq
    }
}

fn __list_repr(a list) str {
    var parts = []
    for i in 0..__listlen(a) {
        __list_push(parts, repr(__list_getitem(a, i)))
    }
    __str_join('', [
        '[',
        __str_join(', ', parts),
        ']',
    ])
}
