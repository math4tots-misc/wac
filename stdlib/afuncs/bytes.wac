# bytes layout look like:
#   [i32 refcnt][i32 nbytes][i32 capacity][i32 ptr]
# (layout is similar to list)
#
# little endian is assumed unless specified otherwise
#

const __WAC_bytes_offset_size = 4
const __WAC_bytes_offset_capacity = 8
const __WAC_bytes_offset_buffer = 12

trait bytes(self) bytes

impl i32 for bytes(self) bytes {
    var ret = __new_bytes()
    ret.Push1(self)
    ret
}

impl bytes for bytes(self) bytes {
    self
}

impl list for bytes(self) bytes {
    var ret = __new_bytes()
    for i in 0..self.Size() {
        ret.Extend(self.Get(i))
    }
    ret
}

fn bytes.Size[notrace](self) i32 {
    $read4($asm([], i32, "local.get $l_0_self"), offset: __WAC_bytes_offset_size)
}

# Gets a raw pointer to the buffer containing the data
fn bytes.PointerToRawData[notrace](self) i32 {
    $read4($raw(self), offset: __WAC_bytes_offset_buffer)
}

# Get a single byte at index
fn bytes.Get1(self, index i32) i32 {
    var size = self.Size()
    index = __index(index, size)
    var buffer = $read4($asm([], i32, "local.get $l_0_self"), offset: __WAC_bytes_offset_buffer)
    $read1(buffer + index)
}

fn bytes.Set1(self, index i32, byte i32) {
    var size = self.Size()
    index = __index(index, size)
    var buffer = $read4($asm([], i32, "local.get $l_0_self"), offset: __WAC_bytes_offset_buffer)
    $write1(buffer + index, byte)
}

# Get a 2-byte value at an index
fn bytes.Get2(self, index i32) i32 {
    self.Get1(index) | self.Get1(index + 1) << 8
}

# Set a 2-byte value at an index
fn bytes.Set2(self, index i32, value i32) {
    self.Set1(index, value & 0xFF)
    self.Set1(index + 1, (value >> 8) & 0xFF)
}

# Get a 4-byte value at an index
fn bytes.Get4(self, index i32) i32 {
    self.Get2(index) | self.Get2(index + 2) << 16
}

# Set a 4-bit value at an index
fn bytes.Set4(self, index i32, value i32) {
    self.Set2(index, value & 0xFFFF)
    self.Set2(index, (value >> 16) & 0xFFFF)
}

# Get an 8-byte value at an index
fn bytes.Get8(self, index i32) i64 {
    (self.Get4(index).ExtendUnsigned() |
        self.Get4(index + 4).ExtendUnsigned() << 32)
}

fn bytes.Resize[notrace](self, size i32) {
    __bytes_resize(self, size)
}

fn bytes.Push1[notrace](self, byte i32) {
    __bytes_push(self, byte)
}

fn bytes.Push2[notrace](self, value i32) {
    self.Push1(value & 0xFF)
    self.Push1((value >> 8) & 0xFF)
}

fn bytes.Push4[notrace](self, value i32) {
    self.Push2(value & 0xFFFF)
    self.Push2((value >> 16) & 0xFFFF)
}

fn bytes.Push8[notrace](self, value i64) {
    self.Push4((value & 0xFFFFFFFF).Wrap())
    self.Push4(((value >> 32) & 0xFFFFFFFF).Wrap())
}

fn bytes.ExtendWithBytes(self, other bytes) {
    for i in 0..other.Size() {
        self.Push1(other.Get1(i))
    }
}

fn bytes.Extend(self, other id) {
    self.ExtendWithBytes(bytes(other))
}
