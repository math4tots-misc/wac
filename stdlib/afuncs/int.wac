# cast an i32 to an i64, without extending the signed bit
fn i32.ExtendUnsigned[notrace](self) i64 {
    $asm([self], i64, "i64.extend_i32_u")
}

fn i32.ExtendSigned[notrace](self) i64 {
    $asm([self], i64, "i64.extend_i32_s")
}

fn i64.Wrap[notrace](self) i32 {
    $asm([self], i32, "i32.wrap_i64")
}

# Truncates an i64 integer to an i32
# Basically an unsigned cast
fn i64.Trunc[notrace](self) i32 {
    $asm([self & (0xFFFFFFFF).(i64)], i32, "i32.wrap_i64")
}

fn i32.Abs[notrace](self) i32 {
    if self < 0 {
        -self
    } else {
        self
    }
}

fn i32.Str[notrace](self) str {
    if self is 0 {
        '0'
    } else {
        # account for leading '-'
        var len = if self < 0 { 1 } else { 0 }
        var i = self.Abs()
        while i > 0 {
            len = len + 1
            i = i // 10
        }

        var ret = __WAC_str_alloc(len)
        var buf = __WAC_str_buffer(ret)
        if self < 0 {
            $write1(buf, $char('-'))
        }
        var ptr = buf + len
        i = self.Abs()
        while i > 0 {
            ptr = ptr - 1
            $write1(ptr, $char('0') + i % 10)
            i = i // 10
        }

        ret
    }
}

fn i32.Pow[notrace](self, n i32) i32 {
    var ret = 1
    for _ in 0..n {
        ret = ret * self
    }
    ret
}
