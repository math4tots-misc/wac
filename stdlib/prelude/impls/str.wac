
# str layout:
#   [refcnt i32][len(bytes) i32][utf8...]
#
fn __WAC_str_release[notrace](ptr i32) {
    var refcnt = __read(ptr) - 1
    if refcnt > 0 {
        __write(ptr, refcnt)
    } else {
        __free(__read(ptr + 4) + 8, ptr)
    }
}

fn __WAC_str_alloc[notrace](strlen i32) str {
    # Allocates space for string of a given length
    var ptr = __malloc(8 + strlen)
    __write(ptr, 1)           # refcnt
    __write(ptr + 4, strlen)  # strlen in bytes
    $asm([ptr], str, "")
}

fn __WAC_str_buffer[notrace](s str) i32 {
    # Returns the pointer to the string's buffer
    $asm([], i32, r###"
        local.get $l_0_s
        i32.const 8
        i32.add
    "###)
}

# Joins a list of strings with the given separator
fn __str_join[notrace](separator str, items list) str {
    var separator_len = __strlen(separator)
    var separator_buffer = __WAC_str_buffer(separator)
    var items_len = __listlen(items)

    var final_len = 0
    var i = 0
    while i < items_len {
        if i > 0 {
            final_len = final_len + separator_len
        }
        final_len = final_len + __strlen(__list_getitem(items, i))
        i = i + 1
    }

    var ret = __WAC_str_alloc(final_len)
    var buffer = __WAC_str_buffer(ret)

    i = 0
    while i < items_len {
        if i > 0 {
            __WAC_memcpy(buffer, separator_buffer, separator_len)
            buffer = buffer + separator_len
        }
        var item str = __list_getitem(items, i)
        var item_len = __strlen(item)
        var item_buffer = __WAC_str_buffer(item)
        __WAC_memcpy(buffer, item_buffer, item_len)
        buffer = buffer + item_len
        i = i + 1
    }

    ret
}

# concatenates two strings
fn __str_cat[notrace](a str, b str) str {
    var alen = __strlen(a)
    var blen = __strlen(b)
    var strlen = alen + blen
    var ret = __WAC_str_alloc(strlen)

    var abuf = __WAC_str_buffer(a)
    var bbuf = __WAC_str_buffer(b)
    var rbuf = __WAC_str_buffer(ret)

    __WAC_memcpy(rbuf,        abuf, alen)
    __WAC_memcpy(rbuf + alen, bbuf, blen)

    ret
}

fn __str_eq(a str, b str) bool {
    var alen = __strlen(a)
    var blen = __strlen(b)
    var abuf = __WAC_str_buffer(a)
    var bbuf = __WAC_str_buffer(b)

    if alen is blen {
        var eq_so_far = true
        var i = 0
        while eq_so_far and i + 4 < alen {
            eq_so_far = __read(abuf + i) is __read(bbuf + i)
            i = i + 4
        }
        while eq_so_far and i < alen {
            eq_so_far = __read_u8(abuf + i) is __read_u8(bbuf + i)
            i = i + 1
        }
        eq_so_far
    } else {
        false
    }
}

fn __cstrlen[notrace](cstr i32) i32 {
    if cstr is 0 {
        0
    } else {
        var i = 0
        while __read_u8(cstr + i) is not 0 {
            i = i + 1
        }
        i
    }
}

fn __eprint0_cstr[notrace](cstr i32) {
    __eprint0_str_raw(__cstrlen(cstr), cstr)
}

fn __eprint0_i32[notrace](x i32) {
    __eprint0_str(__i32_str(x))
}

fn __print0_cstr[notrace](cstr i32) {
    __print0_str_raw(__cstrlen(cstr), cstr)
}

fn __print0_str[notrace](s str) {
    var ptr = __WAC_UNSAFE_strptr(s)
    __print0_str_raw(__read(ptr + 4), ptr + 8)
}

fn __print_str[notrace](s str) {
    __print0_str(s)
    __print0_str('\n')
}

fn __eprint0_str[notrace](s str) {
    var ptr = __WAC_UNSAFE_strptr(s)
    __eprint0_str_raw(__read(ptr + 4), ptr + 8)
}

fn __eprint_str[notrace](s str) {
    __eprint0_str(s)
    __eprint0_str('\n')
}

fn __strlen[notrace](s str) i32 {
    # Gets the length of the given string
    # (i.e. number of bytes in its utf8 representation)
    var ptr = $asm([], i32, "local.get $l_0_s")
    __read(ptr + 4)
}

fn __WAC_UNSAFE_strptr[notrace](s str) i32 {
    # Returns the given str as an i32
    # This is unsafe since if the last reference was given,
    # the returned pointer would point to freed data
    $asm([], i32, "local.get $l_0_s")
}

fn __str_slice[notrace](s str, start i32, end i32) str {
    var slen = __strlen(s)
    var start = __index(start, slen)
    var end = __end_index(end, slen)

    if start < end {
        var slice_len = end - start
        var ret = __WAC_str_alloc(slice_len)
        var src_buffer = __WAC_str_buffer(s)
        var ret_buffer = __WAC_str_buffer(ret)
        __WAC_memcpy(ret_buffer, src_buffer + start, slice_len)
        ret
    } else {
        ""
    }
}

fn __str_format(fmt str, args list) str {
    var fmt_len = __strlen(fmt)
    var fmt_buf = __WAC_str_buffer(fmt)
    var parts = []

    var argc = __listlen(args)
    var argi = 0
    var next_part_start = 0
    var i = 0
    while i < fmt_len {
        var ch = __read_u8(fmt_buf + i)

        # 37 is '%'
        if ch is 37 {
            __list_push(parts, __str_slice(fmt, next_part_start, i))
            next_part_start = i + 2

            i = i + 1
            if i >= fmt_len {
                NoTracePanic("Format string ended with '%'")
            }
            ch = __read_u8(fmt_buf + i)

            if ch is 37 {
                # 37 is '%'
                Push(parts, '%')
            } else {
                if argi >= argc {
                    NoTracePanic("Not enough arguments in str format")
                }
                var arg = args[argi]
                argi = argi + 1

                if ch is 114 {
                    # 114 is 'r'
                    Push(parts, repr(arg))
                } else if ch is 115 {
                    # 115 is 's'
                    Push(parts, str(arg))
                } else {
                    NoTracePanic("Unrecognized format char")
                }
            }
        }

        i = i + 1
    }

    if next_part_start < fmt_len {
        __list_push(parts, __str_slice(fmt, next_part_start, fmt_len))
    }

    if argi < argc {
        NoTracePanic("Too many arguments in str format")
    }

    __str_join("", parts)
}
