
# bytes look like:
#   [i32 refcnt][i32 nbytes][i32 capacity][i32 ptr]
# (layout is similar to list)

fn __WAC_bytes_release[notrace](ptr i32) {
    var refcnt = __read(ptr) - 1
    if refcnt > 0 {
        __write(ptr, refcnt)
    } else {
        var len = __read(ptr + 4)
        var buf = __read(ptr + 12)

        # free the bytes
        __free(__read(ptr + 8), buf)

        # free the info
        __free(16, ptr)
    }
}

fn __new_bytes[notrace]() bytes {
    var ptr = __malloc(16)

    # refcnt
    __write(ptr, 1)

    # len (starts empty)
    __write(ptr + 4, 0)

    # capacity (starts with no allocation)
    __write(ptr + 8, 0)

    # ptr to bytes (starts as null)
    __write(ptr + 12, 0)

    $asm([], bytes, "local.get $l_0_ptr")
}

fn __bytes_resize[notrace](bts bytes, new_size i32) {
    var old_size = __bytes_len(bts)

    for _ in old_size..new_size {
        __bytes_push(bts, 0)
    }

    var buf = $asm([], i32, "local.get $l_0_bts")
    __write(buf + 4, new_size)
}

fn __bytes_len[notrace](bts bytes) i32 {
    __read($asm([], i32, "local.get $l_0_bts") + 4)
}

# Get the byte at given index
fn __bytes_getitem[notrace](bts bytes, i i32) i32 {
    var bts = $asm([], i32, "local.get $l_0_bts")
    __read_u8(__read(bts + 12) + i)
}

# Set the byte at given index
fn __bytes_setitem[notrace](bts bytes, i i32, byte i32) {
    var bts = $asm([], i32, "local.get $l_0_bts")
    if byte < 0 or byte > 0xFF {
        NoTracePanic(__str_join(
            '',
            [
                'Byte value outside (0, 0xFF) (',
                __i32_str(byte),
                ')',
            ]
        ))
    }
    __write_u8(__read(bts + 12) + i, byte)
}

fn __bytes_push[notrace](buf bytes, byte i32) {
    var raw_bytes = $asm([], i32, "local.get $l_0_buf")
    __WAC_bytes_push_raw(raw_bytes, byte)
}

fn __WAC_bytes_push_raw[notrace](btsptr i32, byte i32) {

    var len = __read(btsptr + 4)
    var capacity = __read(btsptr + 8)

    if capacity < len + 1 {
        var new_capacity = if capacity is 0 {
            2
        } else {
            capacity * 4
        }

        # Update the 'capacity' field
        __write(btsptr + 8, new_capacity)

        # Update with larger bytes
        __write(
            btsptr + 12,
            __realloc(capacity, new_capacity, __read(btsptr + 12)),
        )
    }

    # update the 'len' field
    __write(btsptr + 4, len + 1)

    var buffer = __read(btsptr + 12)

    if byte < 0 or byte > 0xFF {
        NoTracePanic(__str_join(
            '',
            [
                'Byte value outside (0, 0xFF) (',
                __i32_str(byte),
                ')',
            ]
        ))
    }
    __write_u8(buffer + len, byte)
}

fn __bytes_pop[notrace](buf bytes) i32 {
    # There's no need to release manually,
    # we're just transferring the retain that this bytes had to the
    # reference to the retain we would've needed to do for a
    # return value
    __WAC_bytes_pop_raw_no_release($asm([], i32, "local.get $l_0_buf"))
}

fn __WAC_bytes_pop_raw_no_release[notrace](buf i32) i32 {
    var new_len = __read(buf + 4) - 1
    if new_len < 0 {
        NoTracePanic("Pop from empty bytes")
    }
    __write(buf + 4, new_len)

    # buf[new_len]
    __read_u8(__read(buf + 12) + new_len)
}

fn __bytes_repr[notrace](bts bytes) str {
    var parts = ['bytes[']

    for i in 0..__bytes_len(bts) {
        if i is not 0 {
            __list_push(parts, ', ')
        }
        __list_push(parts, __i32_str(__bytes_getitem(bts, i)))
    }

    __list_push(parts, ']')

    __str_join('', parts)
}

fn __bytes_str[notrace](bts bytes) str {
    # TODO: Check that the generated string is valid UTF-8
    var len = __bytes_len(bts)
    var ret = __WAC_str_alloc(len)
    var strbuf = __WAC_str_buffer(ret)
    __WAC_memcpy(strbuf, __bytes_buffer(bts), len)
    ret
}

fn __bytes_buffer[notrace](bts bytes) i32 {
    $asm([], i32, "local.get $l_0_bts")
}
